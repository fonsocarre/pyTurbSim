#! /usr/bin/env python3
import argparse

import numpy as np
import sys
from tvtk.api import tvtk, write_data
import h5py as h5
import os
import json
"""
see
http://lkilcher.github.io/pyTurbSim/api/pyts.html?highlight=tsdata#pyts.main.tsdata
and
http://lkilcher.github.io/pyTurbSim/api/pyts.html?highlight=tsdata#pyts.base.gridProps
"""
# Disable
def blockPrint():
    sys.stdout = open(os.devnull, 'w')

# Restore
def enablePrint():
    sys.stdout = sys.__stdout__

def read_input(input_file):
    d = dict()
    with open(input_file) as f:
        for line in f:
            try:
                key = line.split()[1]
                val = line.split()[0]
            except IndexError:
                continue
            d[key] = val
    return d

def reduce_4dmatrix(mat):
    new_mat = mat[:, ::2, ::2, ::2].copy()
    return new_mat

def reduce_vector(vec):
    new_vec = vec[::2].copy()
    return new_vec

# def read_btl(file):
#     print('Reading btl file...', filename + '.btl')
#     data = tsread.turbsim(filename + '.btl')
#     print('\tOK')
#     print('Reading inp file...', filename + '.inp')
#     input_data = read_input(filename + '.inp')
#     print('\tOK')
#     return data, input_data

def read_turb(file):
    # read header file
    header = None
    with open(file) as f:
        header = json.load(f)

    class Struct:
        def __init__(self):
            pass
    data_input = Struct()
    data_input.l = header['l']
    data_input.n = header['n']
    data_input.d = header['d']
    data = Struct()
    # read velocity files
    in_file = header['files']['ux'][0]
    with open(in_file, 'rb') as f:
        ux = np.fromfile(f, dtype=np.float64)
        data.u = ux.reshape((data_input.n[0], data_input.n[1], data_input.n[2]), order='F')
    in_file = header['files']['uy'][0]
    with open(in_file, 'rb') as f:
        uy = np.fromfile(f, dtype=np.float64)
        data.v = uy.reshape((data_input.n[0], data_input.n[1], data_input.n[2]), order='F')
    in_file = header['files']['uz'][0]
    with open(in_file, 'rb') as f:
        uz = np.fromfile(f, dtype=np.float64)
        data.w = uz.reshape((data_input.n[0], data_input.n[1], data_input.n[2]), order='F')

    data.x_grid = np.linspace(0, data_input.l[0], data_input.n[0])
    data.y_grid = np.linspace(0, data_input.l[1], data_input.n[1])
    data.z_grid = np.linspace(0, data_input.l[2], data_input.n[2])

    # have to change the coordinates:
    # binary          output
    # x         --->    x
    # y         --->    z
    # z         --->    -y
    data.y_grid, data.z_grid = -data.z_grid, data.y_grid
    data.y_grid -= np.min(data.y_grid)
    data.y_grid = data.y_grid[::-1]
    data.v, data.w = -data.w, data.v

    data.u = np.swapaxes(data.u, 1, 2)
    data.v = np.swapaxes(data.v, 1, 2)
    data.w = np.swapaxes(data.w, 1, 2)

    data.utotal = np.zeros((3, data.z_grid.size, data.y_grid.size, data.x_grid.size))
    for i in range(len(data.x_grid)):
        for j in range(len(data.y_grid)):
            for k in range(len(data.z_grid)):
                data.utotal[0, k, j, i] = data.u[i, j, k]
                data.utotal[1, k, j, i] = data.v[i, j, k]
                data.utotal[2, k, j, i] = data.w[i, j, k]

    return data

parser = argparse.ArgumentParser(prog='btsh5', description=
"""This script converts a turbsim .btl file or binary turbulence into a compressed hdf5 file.\n
Paraview output is also supported.\n
Alfonso del Carre. \n
Imperial College London 2018""")
parser.add_argument('filename', help='path to the file to be converted', type=str)
parser.add_argument('-o', '--output', help='output file path and name (extension will be disregarded)', type=str, default='', const='', nargs='?')
parser.add_argument('-p', '--paraview', help='enables Paraview output', action='store_true')
parser.add_argument('--output_profile', help='plot in matplotlib the average velocity profile', action='store_true')
parser.add_argument('-c', '--coarsen', help='coarsen the mesh by a factor', type=int, default=0, const=0, nargs='?')
parser.add_argument('-n', '--no_hdf5', help='suppress generation of custom HDF5 file', action='store_true')
args = parser.parse_args()

filename = os.path.splitext(args.filename)[0]
extension = os.path.splitext(args.filename)[-1]
if not args.output == '':
    out_filename = os.path.splitext(args.output)[0]
else:
    out_filename = filename


blockPrint()
#TODO generalise
# sys.path.append('/home/ad214/Desktop/untitled\ folder/pyTurbSim')
import pyts.io.read as tsread
enablePrint()

if extension == '.json':
    data = read_turb(filename + extension)
else:
    raise Exception('Not correct file type')
# elif extension == 'json':
#     # read
#     data = read_binary(filename)


# velocity matrix
velocity = data.utotal
# time vector
try:
    time = data.time
    dt = data.time[1] - data.time[0]
    x_grid = time*u_inf
    y_grid = data.grid.y
    z_grid = data.grid.z
except AttributeError:
    x_grid = data.x_grid
    y_grid = data.y_grid
    z_grid = data.z_grid

try:
    u_inf = float(input_data['URef'])
    ref_height = float(input_data['RefHt'])
except NameError:
    u_inf = -1
    ref_height = -1


if args.coarsen:
    for i_coarse in range(args.coarsen):
        print('Coarsening mesh... ',  str(i_coarse + 1))
        time = reduce_vector(time)
        y_grid = reduce_vector(y_grid)
        z_grid = reduce_vector(z_grid)
        velocity = reduce_4dmatrix(velocity)
        print('Dimensions: ', velocity.shape)

# calculate average field
if args.output_profile:
    import matplotlib.pyplot as plt
    nz = len(z_grid)
    average_field = np.zeros((nz, 3))
    for k in range(nz):
        for i_dim in range(3):
            average_field[k, i_dim] = np.average(velocity[i_dim, k, :, :])

    plt.figure()
    colours = ['k', 'r', 'b']
    for i_dim in range(3):
        plt.plot(average_field[:, i_dim], z_grid, colours[i_dim])
    plt.title('Average velocity profile')
    plt.legend(('u', 'v', 'w'), loc='upper center')
    plt.xlabel('velocity [m/s]')
    plt.ylabel('height [m]')
    plt.grid(True)
    plt.draw()

if args.paraview:
    # grid
    y, z, x = np.meshgrid(y_grid, z_grid, x_grid, indexing='xy')
    # import pdb; pdb.set_trace()
    points = np.zeros((y.size, 3))
    out_velocity = np.zeros((y.size, 3))
    counter = 0
    # probably can be done with a 1D pointer
    for i in range(y.shape[2]):
        for j in range(y.shape[1]):
            for k in range(y.shape[0]):
                # points[counter, :] = [x[j, k, i], y[j, k, i], z[j, k, i]]
                points[counter, :] = [x[k, j, i], y[k, j, i], z[k, j, i]]
                out_velocity[counter, :] = velocity[:, k, j, i]
                counter += 1
    sg = tvtk.StructuredGrid(dimensions=x.shape, points=points)
    sg.point_data.vectors = out_velocity
    sg.point_data.vectors.name = 'velocity'
    print('Writing paraview file to... ', out_filename + '.vts')
    write_data(sg, out_filename)
    print('\tOK')

if not args.no_hdf5:
    print('Writing HDF5 file to... ', out_filename + '.h5')
    with h5.File(out_filename + '.h5', 'w') as f:
        # time vector
        try:
            dset = f.create_dataset("time", data=time)
            dset.attrs['unit'] = 's'
        except NameError:
            pass
        # dimensions
        dimensions = np.array(velocity.shape)
        dset = f.create_dataset('dimensions', data=dimensions)
        dset.attrs['variables'] = 'dim, z, y, x'
        # grid
        dset = f.create_dataset('x_grid', data=x_grid)
        dset.attrs['unit'] = 'm'
        dset = f.create_dataset('y_grid', data=y_grid)
        dset.attrs['unit'] = 'm'
        dset = f.create_dataset('z_grid', data=z_grid)
        dset.attrs['unit'] = 'm'
        # data group
        datagroup = f.create_group('data')
        # velocity
        dset = datagroup.create_dataset('velocity', data=velocity, compression='gzip')
        dset.attrs['unit'] = 'm/s'
        # uhub
        dset = f.create_dataset('u_inf', data=u_inf)
        dset = f.create_dataset('ref_height', data=ref_height)
    print('\tOK')

if args.output_profile:
    # keep plots open
    plt.show()
